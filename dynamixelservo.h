#ifndef DYNAMIXELSERVO_H
#define DYNAMIXELSERVO_H

#include <QObject>
//#include <qextserialport.h>
#include <QByteArray>
#include <QBitArray>
#include <QTimer>
#include <QMutex>

#define READ_DATA 0x02
#define WRITE_DATA 0x03
#define WRITE_REG 0x04
#define ACTION 0x05
#define RESET 0x06

#define BROADCAST 0xfe

#define GOAL_POSITION 0x1e
#define SPEED 0x20
#define CW_ANGLE_LIMIT 0x06
#define CCW_ANGLE_LIMIT 0x08
#define CW_DIRECTION 1
#define CCW_DIRECTION 0

#define NO_INFO_RET 0
#define ASK_INFO_RET 1
#define ALL_INFO_RET 2

class DynamixelServo : public QObject
{
  Q_OBJECT

public:
  explicit DynamixelServo(quint8 id, QextSerialPort *device, QObject *parent = 0);
  ~DynamixelServo();

  // used during servo mode
  bool setSpeed(double Speed, bool broadcast); //in percent  // Return true if operation succesfull
  bool setAngle(double angle, bool now); //0-300 degree //sets goal angle position
                                        //If now is FALSE, need to use updateServo to make ACTION
  bool setAngleAndSpeed(double angle, double Speed, bool now);
  bool setCWAngleLimit(double CWAngle); //min 0 //sets minimum clockwise angle
  bool setCCWAngleLimit(double CCWAngle); //max 300 //sets maximum counter clockwise angle

  // used during wheel mode
  bool setWheelMode(bool enable, bool broadcast); //changes to wheel mode
                                                  //broadcast DOESN't WORK if returning FROM wheel mode
  bool setDirectionAndSpeed(quint8 direction, double Speed, bool now);
  bool stop(bool now, bool broadcast);
  bool setMaxTorque(double torque); //sets maxim torque (in percent) generated by servo
                                    //if actual torque > max, servo stops //it also changes movement speed

  //used in every mode
  bool updateServo(bool broadcast); //makes ACTION //this or broadcast
  bool setTorqueOFF(bool broadcast); //it stops continious running on wheel mode

  bool setStatusReturnPackage(quint8 info, bool broadcast); //sets if status package will be returned, after command/info package
                                                            //0 - no return
                                                            //1 - read only
                                                            //2 - all
  bool setAlarmLeds(bool enable, bool broadcast); //turns ON/OFF blinking led when error occurs
  bool turnLed(bool broadcast); //it switches LED ON/OFF, e.g. used for check if communication is properly

  bool getIfMoving(bool &moving); //gets if servo is moving to Goal Position or it already reached GP
  bool getPresentAngle(quint16 &value);  //gets current angle
  bool getPresentVoltage(quint8 &value); //gets current voltage *10 (40->4V)
  bool getActualSpeed(quint16 &value);   //gets actual moving speed
  bool getSettedPosition(quint16 &value); //gets goal position

  bool delay(int msc); //makes delay of msc miliseconds
  //temporary, should be deleted before final version
  bool temp;
  bool torque;
  bool CCWAngleLimit;


private:
  QextSerialPort *device;  //Serial Port Device ( One for all UartServos)
  quint8 id; //1 - fabric, 2-250
  QByteArray byteArray; //array used for sending, counting CRC etc data
  QTimer *timer;
  //QMutex mutex;

  bool LedOn;
  bool timerOut;
  quint8 CWAngleLimitHB; //neccessary to go back from wheel mode properly
  quint8 CWAngleLimitLB;
  quint8 CCWAngleLimitHB; //neccessary to go back from wheel mode properly
  quint8 CCWAngleLimitLB;

  bool addCRC(QByteArray &array);
  bool send(const QByteArray array);

private slots:
  bool setTimerOut();
};

#endif // DYNAMIXELSERVO_H
